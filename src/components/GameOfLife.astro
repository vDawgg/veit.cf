---
//TODO: Set gridSize and rectSize via component props! 
---

<script>
    //TODO: Find out what effect the padding has here!

    //TODO: This should probably be dynamic as well as it might need
    //more optimization otherwise
    //Set the grid size
    let gridSize: number = 600;

    //Set the canvas rectangle sizes
    let rectSize: number = 2;

    const create2dArray = (rows: number, columns: number) =>
        [...Array(rows).keys()].map((i) => Array(columns));

    //Array representation of grid contains a bool for whether the cell is dead
    let gridArr: Boolean[][] = create2dArray(gridSize, gridSize);

    let grid = document.querySelector("canvas");
    let ctx = grid!.getContext("2d");

    function fitParent(canvas: HTMLCanvasElement) {
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }

    fitParent(grid!);

    //Prefill the array with values
    for (let i = 0; i < gridArr.length; i++) {
        for (let j = 0; j < gridArr[0].length; j++) {
            gridArr[i][j] = false;
        }
    }

    //TODO: Make this its own function with the Math.random size as a parameter
    //Initiate the seed values
    for (let n = 0; n < (gridSize * gridSize) / 2; n++) {
        let x: number = Math.floor(Math.random() * gridSize);
        let y: number = Math.floor(Math.random() * gridSize);

        gridArr[x][y] = true;
    }

    function inBoundsAndLive(x: number, y: number) {
        if (x >= 0 && x < gridArr.length && y < gridArr[0].length && y >= 0) {
            if (gridArr[x][y]) {
                return true;
            }
        }
        return false;
    }

    class Cell {
        x;
        y;
        constructor(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }

    function runGame() {
        for (let i = 0; i < gridArr.length; i++) {
            for (let j = 0; j < gridArr[0].length; j++) {
                if (gridArr[i][j] == true) {
                    reviveCell(ctx, i * rectSize, j * rectSize);
                }
            }
        }

        //printGame(gridArr);

        setInterval(() => {
            let changed = new Map();

            //Compute new state
            for (let i = 0; i < gridArr.length; i++) {
                for (let j = 0; j < gridArr[0].length; j++) {
                    let neighbors = 0;

                    //Check up
                    neighbors += inBoundsAndLive(i + 1, j) ? 1 : 0;
                    //Check down
                    neighbors += inBoundsAndLive(i - 1, j) ? 1 : 0;
                    //Check left
                    neighbors += inBoundsAndLive(i, j - 1) ? 1 : 0;
                    //Check right
                    neighbors += inBoundsAndLive(i, j + 1) ? 1 : 0;
                    //Check top-left
                    neighbors += inBoundsAndLive(i + 1, j - 1) ? 1 : 0;
                    //Check top-right
                    neighbors += inBoundsAndLive(i + 1, j + 1) ? 1 : 0;
                    //Check bottom-left
                    neighbors += inBoundsAndLive(i - 1, j - 1) ? 1 : 0;
                    //Check bottom-right
                    neighbors += inBoundsAndLive(i - 1, j + 1) ? 1 : 0;

                    let cell = new Cell(i, j);
                    //Live cell with less than two neighbors -> Cell dies
                    if (gridArr[i][j] && neighbors < 2)
                        changed.set(cell, false);
                    //Live cell with more than three neighbors -> Cell dies
                    else if (gridArr[i][j] && neighbors > 3)
                        changed.set(cell, false);
                    //Dead cell with three neighbors -> Cell lives
                    else if (!gridArr[i][j] && neighbors == 3)
                        changed.set(cell, true);
                }
            }

            //Update to new state
            for (const [k, v] of changed) {
                if (!v) {
                    //console.log("Killing cell: ", k);
                    gridArr[k.x][k.y] = false;
                    killCell(ctx, k.x * rectSize, k.y * rectSize);
                } else {
                    //console.log("Revicing cell: ", k);
                    gridArr[k.x][k.y] = true;
                    reviveCell(ctx, k.x * rectSize, k.y * rectSize);
                }
            }

            //printGame(gridArr);
        }, 60);
    }

    function reviveCell(ctx: any, x: number, y: number) {
        ctx.fillStyle = "white";
        ctx.fillRect(x, y, rectSize, rectSize); //The third and fourth arguments specify the size of the rectangle
    }

    function killCell(ctx: any, x: number, y: number) {
        ctx.clearRect(x, y, rectSize, rectSize);
    }

    function printGame(grid: Boolean[][]) {
        for (let i = 0; i < grid.length; i++) {
            let s = "";

            for (let j = 0; j < grid[0].length; j++) {
                if (grid[i][j]) {
                    s += "x";
                } else {
                    s += "-";
                }
            }

            console.log(s);
        }
    }

    window.onload = runGame;
</script>

<!--- TODO: Fix scaling issues! --->
<!--- Find out if the size of the canvas can be dynamic! -->
<canvas id="grid" class="absolute"><canvas>
